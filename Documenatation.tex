
%importing all the packages

\documentclass[12pt,a4paper]{article}
\usepackage{graphicx}
\usepackage{setspace}
\usepackage{geometry}
\usepackage{ragged2e}
\usepackage{xcolor}
\usepackage{makeidx} 
\usepackage{graphicx}
\usepackage{caption} % For \caption*
\usepackage{amsmath, amssymb}
\usepackage{hyperref}
\usepackage{fancyhdr} 


   
\makeindex           



\geometry{margin=2cm}

% Default page style for prelim pages (title, certificate etc)
\pagestyle{plain}

% Define custom header/footer style starting from Introduction page
\fancypagestyle{introstyle}{
	\fancyhf{} % clear existing header and footer
	\fancyhead[L]{Movie recommendation system}    % Header left           %a=ADD YOUR PROJECT NAME HERE
	\fancyfoot[L]{Dept of CSE, ACSCE}              % Footer left
	\fancyfoot[C]{\thepage}                        % Footer center: page number
	\fancyfoot[R]{2025-26}                         % Footer right
	\renewcommand{\headrulewidth}{0.4pt}          % Header rule
	\renewcommand{\footrulewidth}{0.4pt}          % Footer rule
}

\begin{document}
	
	% Title Page
	\begin{titlepage}
		\centering
		\textsc{\Large Visvesvaraya Technological University}\par
		\textsc{Jnana Sangama, Belagavi, Karnataka} \par
		\vspace{1cm}
		\includegraphics[width=0.3\textwidth]{vtu.png}
		
		\vspace{0.5cm}
		\textbf{\huge Project Report on}\par
		\vspace{0.5cm}
		\textbf{\Large "Movie Recommendation System"}\par
		\vspace{0.5cm}
		\textbf{\large Submitted in the partial fulfillment Requirement for the 5th Sem}\par
		\vspace{0.5cm}
		{\Large BACHELOR OF ENGINEERING} \par
		In \par
		Department of Computer Science and Engineering \par
		\vspace{0.5cm}
		{\large Ravishankar V (1AH23CS122)}\par    %YOUR NAME
		\vspace{1cm}
		\textbf{\large Under the Guidance of }\par
		\vspace{0.5cm}
		Mr. Panchaxari Mamadapur \par
		Assistant Professor, Department of CSE \par
		\vspace{0.5cm}
		\includegraphics[width=0.3\textwidth]{acs.png}
		
		\vspace{0.5cm}
		{\Large ACS College of Engineering}\par
		74, Kambipura Mysore Road, Bangalore-560074 \par
		2024-25 \par
		\vspace{0.2cm}
	\end{titlepage}
	
	% Page numbering for preliminaries in roman numerals
	\pagenumbering{roman}
	
	% Certificate Page
	\begin{center}
		\textbf{\Large Visvesvaraya Technological University}\\[6pt]
		\textbf{\small Jnana Sangama BELAGAVI}\\[12pt]
		\includegraphics[scale=0.20]{vtu.png}\\[12pt]
		\textbf{\small DEPARTMENT OF COMPUTER SCIENCE AND ENGINEERING}\\[12pt]
		\textbf{\Large CERTIFICATE}
	\end{center}
	
	\vspace{5mm}
	\justify{
		This is to certify that Ravishankar V bearing USN: 1AH23CS122 is a bonafide student of
		Bachelor of Engineering course of the Department of Computer Science and Engineering,
		VTU, Belagavi, affiliated to Visvesvaraya Technological University, Belagavi. This project report on
		"Movie Recommendation System" is prepared by him under the guidance of Mr. Panchaxari Mamadapur
		in partial fulfillment of the requirements for the award of the degree of Bachelor of Engineering
		of Visvesvaraya Technological University, Belagavi, Karnataka.
	}
	
	\vspace{10mm}
	\noindent
	\makebox[\textwidth]{%
		\begin{tabular}{@{}p{5cm}@{\hspace{1cm}}p{5cm}@{\hspace{1cm}}p{5cm}@{}}
			\rule{5cm}{0.4pt} & \rule{5cm}{0.4pt} & \rule{5cm}{0.4pt} \\
			Mr.Panchaxari Mamadapur & Dr. Senthil Kumaran T & Mrs.Keerthi G S \\
			Signature of Guide & Signature of HoD & Signature of Co-ordinator
		\end{tabular}
	}
	
	\begin{center}
		\vspace{10mm}
		\textbf{\small EXTERNAL EXAMINER}
	\end{center}
	
	\vspace{5mm}
	Name of External Examiners \hspace{60mm} Signature with Date\newline
	1.\newline\newline
	2.
	
	\newpage
\begin{center}
	\section*{Table of Contents}
	\vspace{1cm}
	
	\begin{tabular}{|p{13cm}|r|}
		\hline
		\textbf{TITLE} & \textbf{PAGE NO} \\
		\hline
		
		1.\ INTRODUCTION & 1 \\
		\hspace{1em} 1.1 Motivation behind the project & 1 \\
		\hspace{1em} 1.2 Existing System & 1 \\
		\hspace{1em} 1.3 Proposed System & 1 \\
		\hspace{1em} 1.4 Objectives of The Work & 2 \\
		\hline
		
		2.\ LITERATURE SURVEY & 3 \\
		\hline
		
		3.\ SYSTEM REQUIREMENT AND SPECIFICATION & 4 \\
		\hspace{1em} 3.1 System Analysis & 4 \\
		\hspace{1em} 3.2 Functional Requirement & 4 \\
		\hspace{1em} 3.3 Non-Functional Requirement & 4 \\
		\hspace{1em} 3.4 Tools and Technology Required & 5 \\
		\hline
		
		4.\ SYSTEM DESIGN & 8 \\
		\hspace{1em} 4.1 System Architecture & 8 \\
		\hspace{1em} 4.2 Packages and Libraries Used & 10 \\
		\hspace{1em} 4.3 Input \& Output Design & 12 \\
		\hspace{1em} 4.4 Algorithm & 14 \\
		\hline
		
		5.\ SYSTEM IMPLEMENTATION & 18 \\
		\hspace{1em} 5.1 Module Description & 18 \\
		\hline
		
		6.\ SYSTEM TESTING & 28 \\
		\hspace{1em} 6.1 Unit Testing & 28 \\
		\hspace{1em} 6.2 Integration Testing & 31 \\
		\hline
		
		7.\ RESULTS AND DISCUSSION & 35 \\
		\hline
		
	\end{tabular}
\end{center}

		
	\newpage
	
	\newpage
	\section*{\centering List of Figures and tables}
	\begin{center}
		\begin{tabular}{|c|p{10cm}|c|}
			\hline
			\textbf{S.No.} & \textbf{Figure Name} & \textbf{Page No.} \\
			\hline
			1 & 1.1 Performance metrics of existing systems  & 1 \\
			2 & 1.2 Performance metrics of proposed systems & 2 \\
			3 & 3.1 Search bar for movies & 5 \\
			4 & 3.2 Main page & 6 \\
			5 & 3.3 Login / Signup page & 6\\
			6 & 3.4 Recommendation page & 7 \\
			7 & 3.5 Liked movies& 7 \\
			8 & 4.1 Content based filtering & 9 \\
			9 & 4.2 Collaborative filtering & 9 \\
			10& 4.3 System architecture diagram &10 \\
			11 &4.4 Visual representation of recommender systems & 14 \\
			12 &5.1 Data preprocessing and merging  & 21\\
			13 &5.2 First trail to check recommended movies & 24 \\
			14 &5.3 Workflow of recommendation module & 25 \\
			15 &6.1 Test case 1 & 29 \\
			16 &6.2 Similarity scores in recommendation model & 30 \\
			13 &6.3 Integration testing & 33 \\
			14 &6.4 Finalized output for integration testing & 34 \\
			15 &7.1 Output of Movie recommenderX & 36 \\
			
			\hline
		\end{tabular}
	\end{center}
	\newpage
	
	% Switch numbering to Arabic for main content
	\pagenumbering{arabic}
	\thispagestyle{introstyle} % First page with custom header/footer
	\pagestyle{introstyle}     % Apply to all subsequent pages
	
	\section{\centering Introduction}
	\addcontentsline{toc}{section}{Introduction}
	\setcounter{section}{1}
	\subsection{Motivation behind the project}
	
	In today’s digital world, recommendation systems have become an essential part of many online services, including e-commerce, social media, and entertainment platforms. With the rapid growth of content, especially movies available on OTT and streaming platforms, users face tremendous challenges in discovering films that best match their tastes and preferences. The sheer volume of choices often leads to decision fatigue, where users spend more time searching than actually enjoying content.
	
	Movie recommendation systems address this problem by leveraging advanced machine learning algorithms to analyze user behavior, movie metadata, and preferences. By providing personalized movie suggestions, these systems enhance user satisfaction and engagement, making the content discovery process efficient and enjoyable. Such systems are crucial for platforms like Netflix, Amazon Prime Video, and Disney+, which host vast libraries of movies and seek to retain users by offering relevant, curated recommendations.
	
	The motivation behind developing a Movie Recommendation System for this project arises from the need to improve user experiences in navigating large movie databases. The system combines content-based filtering and collaborative filtering approaches to provide accurate and diverse movie recommendations tailored to individual users. This not only helps users find movies they are likely to enjoy but also assists the platform in increasing user retention and satisfaction.
	
\subsection{Existing Systems}
Movie recommendation systems have been widely used in recent years to assist users in discovering relevant content from large movie databases. Most existing systems utilize clustering techniques such as K-Means combined with collaborative filtering to provide personalized recommendations. 

One common approach is K-Means clustering, which segments users based on similar behavior patterns in movie ratings. Advances in clustering, such as the Rat Swarm Optimizer (RSO), have contributed to improved recommendation accuracy and stability. Collaborative filtering typically leverages users' ratings to recommend items favored by similar users, but common challenges include cold-start problems, data sparsity, and scalability issues with large datasets.
\begin{table}[h!]
	\centering
	\resizebox{0.9\textwidth}{!}{
		\begin{tabular}{|l|c|c|c|c|c|}
			\hline
			\textbf{Method} & \textbf{MAE (\%)} & \textbf{RMSE (\%)} & \textbf{Precision (\%)} & \textbf{Recall (\%)} & \textbf{F1 Score (\%)} \\ \hline
			K-Means + Collab. Filtering & 7.12 & 8.43 & 87.15 & 86.23 & 86.21 \\ \hline
			K-Means (RSO Opt.) + Collab. Filtering & 5.68 & 6.89 & 90.12 & 90.28 & 90.10 \\ \hline
		\end{tabular}
	}
	\caption{\textbf{Fig 1.1.} Performance metrics of existing recommendation system approaches.}
	\label{tab:existing_approaches}
\end{table}


\subsection{Proposed System}
The proposed movie recommendation system employs a hybrid approach that combines content-based filtering and collaborative filtering algorithms for more relevant and accurate recommendations.

\begin{itemize}
	\item \textbf{Content-Based Filtering:} Uses TF-IDF vectorization on cleaned movie titles and applies cosine similarity to recommend movies with similar content/features to user preferences.
	\item \textbf{Collaborative Filtering:} Analyzes user rating patterns to identify similar users and recommends movies favored by these users, adjusting recommendations with user frequency scoring.
	\item \textbf{Hybrid Recommendation:} Integrates results from both filtering techniques to leverage their strengths and overcome individual limitations.
\end{itemize}

Additionally, the proposed system is implemented using Python (Flask backend) and React (frontend), processes a large movie dataset (89k+ entries), and provides interactive features such as login/signup, movie search, personalized recommendations, and dynamic updates.

Evaluation metrics based on empirical testing for the proposed model are as follows:

\begin{table}[h!]
	\centering
	\resizebox{0.9\textwidth}{!}{
		\begin{tabular}{|l|c|c|c|c|}
			\hline
			Method & MAE (\%) & RMSE (\%) & Precision (\%) & Recall (\%) \\ \hline
			Hybrid (Content + Collaborative Filtering) & 3.4 & 5.1 & 100 & 67 \\ \hline
		\end{tabular}
	}
	\caption{\textbf{Fig 1.2 }Evaluation metrics for hybrid model.}
\end{table}


	\subsection {Objectives of work}
	
\begin{itemize}
	\item Develop a Personalized Recommendation System: To create a system capable of suggesting movies tailored to individual user preferences by analyzing their viewing history and ratings.
	\item Implement Hybrid Filtering Algorithms: To integrate content-based filtering and collaborative filtering techniques to enhance recommendation accuracy and diversity.
	\item Improve Prediction Accuracy: To utilize machine learning models to predict user ratings accurately and provide relevant movie suggestions.
	\item Handle Large Dataset Efficiently: To process and analyze extensive movie datasets (e.g., 89,000+ movies) while maintaining system scalability and performance.
	\item Address Cold-Start and Sparsity Challenges: To develop mechanisms for recommending new movies and for new users with limited data, thereby reducing cold-start problems.
	\item Create a User-Friendly Interface: To design an interactive, accessible front-end (using React) that allows users to search, rate, and receive movie recommendations seamlessly.
	\item Evaluate and Improve the System: To assess the effectiveness of implemented algorithms using metrics like RMSE, precision, recall, and improve the model iteratively.
\end{itemize}
	% Main Sections...
	% ...
	
	\newpage
	
\section{\centering Literature Review}

Several studies in the field have contributed towards building effective recommendation systems:

\begin{itemize}
	\item Jialing Wang and Jun Zheng, in their paper ``Application of Machine Learning Algorithms in User Behavior Analysis and a Personalized Recommendation System in the Media Industry,'' examined the use of machine learning to analyze user behavior for personalized recommendations in media~\cite{Wang2025}.
	
	\item Robert Kwieci\'nski, Grzegorz Melniczak and Tomasz G\'orecki compared real-time vs batch job recommendations, highlighting challenges in different recommendation approaches~\cite{Kwiecinski2025}.
	
	\item Mushran Siddiqui et al. proposed a regionally adaptable nutrition-centric food recommendation system (FR-RANC) which emphasizes adapting recommendations based on regional preferences~\cite{Siddiqui2025}.
	
	\item Xiaoming Li designed a web content personalized recommendation system combining collaborative filtering improved by K-Means and LightGBM to enhance recommendation accuracy~\cite{Li2025}.
	
	\item Earlier foundational work in recommendation systems includes hybrid collaborative filtering methods, similarity-based models, and matrix factorization techniques that form the basis of modern recommender systems.
	
	\item Datasets such as MovieLens, IMDb, and TMDB have played a crucial role in training and evaluating real-world recommendation systems, enabling large-scale experimentation in both academic and industry research.
	
	\item TF-IDF and Count Vectorizer models continue to be widely used in content-based filtering tasks due to their efficiency and strong baseline performance in text feature extraction.
\end{itemize}


% -----------------------------
% REFERENCES SECTION
% -----------------------------

\subsection*{\centering Other References}

\begin{itemize}
	\item MovieLens Dataset — \url{https://grouplens.org/datasets/movielens/}
	\item TMDB Movie Dataset — \url{https://www.kaggle.com/datasets/tmdb/tmdb-movie-metadata}
	\item IMDb Dataset — \url{https://www.imdb.com/interfaces/}
	\item Scikit-learn TF-IDF Vectorizer Documentation — \url{https://scikit-learn.org/stable/modules/generated/sklearn.feature_extraction.text.TfidfVectorizer.html}
	\item Scikit-learn Count Vectorizer Documentation — \url{https://scikit-learn.org/stable/modules/generated/sklearn.feature_extraction.text.CountVectorizer.html}
\end{itemize}

	
	\newpage
\section{\centering System requirement and specification}

\subsection{System analysis}
Overview:  
The Movie Recommendation System is designed to help users find movies tailored to their preferences. The system analyzes user interactions such as ratings and searches, and recommends movies using collaborative and content-based filtering techniques.

\textbf {Users and Stakeholders:}  
\begin{itemize}
	\item \textbf{End Users:} Movie viewers searching and rating movies.
	\item \textbf{Content Providers:} Individuals/admins who may add or update movie data (if applicable).
	\item \textbf{System Administrators:} Manage database and system maintenance.
\end{itemize}

\textbf {High-Level Use Cases:}  
\begin{itemize}
	\item User Registration/Login.
	\item Searching and filtering movies by genre or title.
	\item Rating and liking movies.
	\item Viewing personalized movie recommendations.
	\item Accessing movie trailers and details.
\end{itemize}

\subsection{Functional Requirements}

The system shall provide the following functional capabilities:

\begin{itemize}
	\item User authentication for secured access.
	\item Movie search functionality with optional filters.
	\item Input and storage of user ratings and likes.
	\item Generating personalized recommendations based on user-item similarity and collaborative filtering.
	\item Display of movie details including trailers.
	\item Ability to view recommended movies and previously watched or liked movies.
\end{itemize}
\subsection{Non-Functional Requirements}




The system shall meet the following non-functional criteria:

\begin{itemize}
	\item System should respond to user queries within 2-4 seconds.
	\item Secure user data handling and authentication procedures.
	\item Scalable design capable of supporting multiple concurrent users.
	\item Reliable system uptime with fault tolerance.
	\item User-friendly interface for easy navigation and interaction.
	\item Maintainability for easy update of movies dataset and recommendation algorithms.
\end{itemize}
\subsection{Tools and Technology Required}

The following tools and technologies are used for the development of the Movie Recommendation System:

\begin{itemize}
	\item \textbf{Programming Language:} Python 3.x
	\item \textbf{Web Framework:} Flask
	\item \textbf{Data Analysis:} Pandas, NumPy, scikit-learn for recommendation algorithms
	\item \textbf{Visualization:} Matplotlib
	\item \textbf{Database:} SQLite, MySQL, or CSV files for movie and user data storage
	\item \textbf{Frontend:} HTML, CSS, React
	\item \textbf{Others:} Git for version control, Jupyter notebooks for prototyping
\end{itemize}


% Image 1 with custom caption
\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.8\textwidth]{Sampleoutput5.png}
	\caption*{\textbf{Fig 3.1}: Search bar for movies}
	\label{fig:3.1}
\end{figure}

\vspace{3cm}

% Multiple images stacked, each in separate figure environment for clear captions
\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.8\textwidth]{Sampleoutput1.png}
	\caption*{\textbf{Fig 3.2}: Mainpage}
	\label{fig:3.2}
\end{figure}

\vspace{2cm}

\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.8\textwidth]{Sampleoutput2.png}
	\caption*{\textbf{Fig 3.3}: Login / Signup page}
	\label{fig:3.3}
\end{figure}

\newpage

\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.8\textwidth]{Sampleoutput3.png}
	\caption*{\textbf{Fig 3.4}: Recommendations page}
	\label{fig:3.4}
\end{figure}

\vspace{2cm}

\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.8\textwidth]{Sampleoutput4.png}
	\caption*{\textbf{Fig 3.5}: Liked movies}
	\label{fig:3.5}
\end{figure}

\newpage
\section{\centering System Design}

\subsection{System Architecture}
The system architecture of the Movie-RecommenderX system is designed using a modular, layered, and scalable structure. Each module is responsible for a specific stage of the recommendation pipeline. This architecture ensures reliability, performance, and clear separation of responsibilities so that developers and evaluators can easily understand, modify, and extend the system.

\subsubsection*{Core Elements}

\begin{itemize}
	\item \textbf{Input Data:}\
	The system uses two primary datasets:
	\begin{itemize}
		\item \textbf{Movie Dataset}: Contains fields such as movie title, genres, keywords, description/overview, IMDb link, and metadata. These attributes are essential for content-based analysis.
		\item \textbf{Ratings Dataset}: Contains user--movie rating values that represent user preferences. These ratings are critical for collaborative filtering.
	\end{itemize}
	Together, the datasets provide both descriptive information (for content-based filtering) and behavioral patterns (for collaborative filtering).
	
	
	\item \textbf{Data Processing:}\
	Raw data from the datasets is first cleaned and transformed to prepare for machine learning tasks. Detailed steps include:
	\begin{itemize}
		\item \textbf{Handling Missing Values:} Missing genres, keywords, or descriptions are replaced with empty strings to maintain matrix consistency.
		\item \textbf{Encoding and Normalization:} Genres and keywords are combined into a unified text-based feature for better representation.
		\item \textbf{TF-IDF Vectorization:} The TF-IDF (Term Frequency–Inverse Document Frequency) vectorizer converts textual features into numerical vectors by measuring how important each word is in a movie description relative to the entire dataset. This helps identify distinguishing words.
		\item \textbf{Count Vectorizer:} In cases where frequency-based analysis is desired, the CountVectorizer generates token count vectors. This can help capture term frequency patterns for certain similarity tasks.
		\item \textbf{Matrix Construction:} A high-dimensional feature matrix is generated, where each row represents a movie and each column represents a unique token from descriptions, genres, or metadata.
	\end{itemize}
	These operations create vector representations that allow computation of similarity between movies.
	
	
	\item \textbf{Filtering Algorithms:}\
	The recommendation system uses a hybrid approach combining content-based and collaborative filtering.
	\begin{itemize}
		\item \textit{Content-Based Filtering:}\
		This method recommends movies similar to ones a user already likes. The system uses the TF-IDF matrix and Count Vectorizer matrix to represent movies numerically. \textbf{Cosine similarity} is then applied to measure similarity between pairs of movies. Cosine similarity determines how close two movie vectors are by measuring the angle between them. A smaller angle implies higher similarity.
		
		\begin{figure}[htbp]
			\centering
			\includegraphics[width=0.8\textwidth]{Content based filtering.png}
			\caption*{\textbf{Fig 4.1} Content based filtering.png}
			\label{fig: 3.6}
		\end{figure}
		
		\item \textit{Collaborative Filtering:}\
		This method analyzes patterns in user ratings. A User--Item Matrix is created, where each row represents a user and each column represents a movie. Similar users are identified based on rating patterns, and movies liked by similar users are recommended.
		
			\begin{figure}[htbp]
			\centering
			\includegraphics[width=0.8\textwidth]{Collaborative filtering.png}
			\caption*{\textbf{Fig 4.2} Collaborative filtering}
			\label{fig: 3.7}
		\end{figure}
		
	\end{itemize}
	
	
	\item \textbf{Recommendation Engine:}\
	This module integrates both filtering methods. A weighted hybrid model combines similarity scores from content-based and collaborative systems to generate more accurate and personalized movie recommendations. The engine performs ranking based on similarity values and presents the top results.
	
	
	\item \textbf{User Interaction Module:}\
	A Flask-based web interface enables users to:
	\begin{itemize}
		\item Search for movies
		\item View detailed movie information
		\item Get personalized recommendations
		\item Submit ratings (used to update collaborative filtering models)
	\end{itemize}
	This module ensures smooth and interactive communication with the backend.
	
	
	\item \textbf{Evaluation Module:}\
	Evaluation ensures that recommendation quality is measurable. The system uses:
	\begin{itemize}
		\item \textbf{RMSE (Root Mean Square Error)}: Measures rating prediction accuracy.
		\item \textbf{MAE (Mean Absolute Error)}: Assesses average prediction error.
		\item \textbf{Precision, Recall, and F1 Score}: Evaluate ranking performance for top recommendations.
	\end{itemize}
\end{itemize}
\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.8\textwidth]{Sampleoutput6.png}
	\caption*{\textbf{Fig 4.3} System architecture diagram}
	\label{fig:3.8}
\end{figure}


\subsubsection*{Detailed Architectural Choices}
The architecture adopts a structured three-layer design to ensure modularity:

\begin{itemize}
	\item \textbf{Presentation Layer}: Provides UI pages, links, forms, and output views built using HTML, CSS, and Flask templates.
	\item \textbf{Logic Layer}: Implements similarity computations, recommendation fusion, text processing, and vector operations.
	\item \textbf{Data Layer}: Stores raw datasets, preprocessed matrices, serialized pickle models, and cached computation results.
\end{itemize}

This structure ensures scalability and easy debugging. The system also follows a client–server architecture where user requests from the browser are processed by the Flask backend.


\subsection{Packages and Libraries Used}
The following Python libraries are essential in implementing the model:

\begin{itemize}
	\item \textbf{pandas}: Data loading, cleaning, preprocessing.
	\item \textbf{numpy}: Matrix and vector operations.
	\item \textbf{scikit-learn}: TF-IDF Vectorizer, CountVectorizer, cosine similarity, and evaluation metrics.
	\item \textbf{nltk}: Stopword removal, stemming, tokenization.
	\item \textbf{flask}: Backend server for the web application.
	\item \textbf{matplotlib / seaborn}: Visualizations for analysis.
	\item \textbf{pickle}: Saving and loading preprocessed data and model files.
\end{itemize}





\newpage
\subsection{ Input / Output Design}

Input and Output (I/O) design defines how data enters the system, how it is processed, and how meaningful results are presented to the user. In the Movie-RecommenderX system, the accuracy of recommendations depends greatly on the quality and structure of the inputs, while the outputs must be clear, relevant, and easily interpretable.

\subsection*{Input Design}

Input design specifies the types and formats of data accepted by the system. Inputs for this project come from both the user and the internal datasets.

\subsubsection*{A. User Inputs}

\textbf{1. Movie Name}\\
The user provides a movie title as input. The system validates this input by converting the text to a standard format, removing irregularities such as extra spaces or special characters, and matching it with the dataset. This input is used to generate similar movie recommendations based on metadata and vector similarity.

\textbf{2. User ID}\\
If collaborative filtering is enabled, a user ID is given as input. The system retrieves all previously rated movies and rating behavior associated with the user. This helps in generating personalized recommendations based on user similarity.

\subsubsection*{B. System Inputs (Dataset Inputs)}

\textbf{1. Movie Metadata}\\
Metadata such as genres, tags, descriptions, cast, and crew are extracted from the dataset. These are transformed into structured feature vectors using techniques like TF-IDF and one-hot encoding. These vectors are essential for computing similarity between movies.

\textbf{2. Ratings Data}\\
The ratings dataset contains User IDs, Movie IDs, rating values, and timestamps. These inputs support collaborative filtering methods, helping the system identify patterns in user behavior.

\subsubsection*{C. Preprocessed Inputs}

The system internally generates additional inputs such as:
\begin{itemize}
	\item TF-IDF feature vectors
	\item Cosine similarity matrices
	\item User rating vectors
	\item Movie feature vectors
\end{itemize}
These are not provided by the user but are required for backend processing.

\subsection*{Output Design}

Output design describes the information delivered to the user after processing the inputs. The output must be concise, meaningful, and helpful for decision-making.

\subsubsection*{A. Recommended Movie List}

The system provides a Top-N list (commonly Top-10) of recommended movies. Each recommendation includes:

\begin{itemize}
	\item \textbf{Movie Title} – The suggested film.
	\item \textbf{Similarity Score} – A numerical value between 0 and 1 indicating similarity to the input movie or user profile.
\end{itemize}

Higher similarity scores represent closer matches, derived from cosine similarity between feature vectors.

\subsubsection*{B. Movie Metadata in Output}

Each recommended movie also displays additional relevant information:

\begin{itemize}
	\item Genres
	\item Description or overview
	\item Tags/keywords
\end{itemize}

This helps users understand why a movie was recommended.

\subsubsection*{C. Rating Information}

The output also includes rating-related information such as:

\begin{itemize}
	\item Average user rating
	\item Number of ratings received
\end{itemize}

This helps users judge the popularity and quality of the recommended movies.

\subsubsection*{D. Additional Optional Outputs}

Depending on system implementation, the output may include:
\begin{itemize}
	\item Movie poster or thumbnail (URL or image)
	\item Release year
	\item Runtime
	\item External ratings (IMDB/Rotten Tomatoes)
\end{itemize}

\subsection*{Input/Output Flow Description}

\begin{enumerate}
	\item User enters a movie name or user ID.
	\item The system retrieves relevant metadata or user history.
	\item Feature vectors are generated and matched using cosine similarity.
	\item The Top-N most relevant movies are selected.
	\item The system displays movie titles, similarity scores, descriptions, and ratings.
\end{enumerate}

\subsection*{Importance of I/O Design}

Effective I/O design ensures:
\begin{itemize}
	\item Smooth interaction between user and recommendation engine
	\item Accurate and efficient data processing
	\item High usability and clarity in displayed results
	\item Easy scalability for future UI or API integration
\end{itemize}

\subsection{Algorithm}

This section describes the core algorithms used in the Movie-RecommenderX system, namely TF-IDF Vectorization, Cosine Similarity, and the Hybrid Recommendation approach. These methods are widely used in modern information retrieval and recommender systems, as discussed in standard textbooks such as \textit{Introduction to Information Retrieval} (Manning et al.) and \textit{Recommender Systems: An Introduction} (Jannach et al.). The following subsections describe these algorithms in detail along with their pseudocode.


\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.8\textwidth]{Recommender system1.png}
	\caption*{\textbf{Fig 4.4} Visual representation of Recommender systems}
	\label{fig: 4.1}
\end{figure}


%------------------------------------------------------------
\subsection*{TF-IDF Vectorization}

TF-IDF (Term Frequency--Inverse Document Frequency) is a numerical representation used to convert textual metadata into feature vectors. It assigns higher weight to important terms that appear frequently in a particular document but rarely across the entire dataset.

\subsubsection*{1. Term Frequency (TF)}

Term Frequency indicates how often a term appears in a document:

\[
TF(t,d) = \frac{\text{Number of times term } t \text{ appears in document } d}{\text{Total number of terms in document } d}
\]

\subsubsection*{2. Inverse Document Frequency (IDF)}

Inverse Document Frequency measures how rare or informative a term is across all documents:

\[
IDF(t) = \log\left(\frac{N}{df(t)}\right)
\]

where $N$ is the total number of documents and $df(t)$ is the number of documents containing term $t$.

\subsubsection*{3. TF-IDF Weight}

The final TF-IDF score is computed as:

\[
TF\text{-}IDF(t,d) = TF(t,d) \times IDF(t)
\]

This produces a high-dimensional vector representation for each movie.

\subsubsection*{Pseudocode for TF-IDF}

\begin{verbatim}
	Algorithm TFIDF_Vectorization(Dataset):
	Input: Movie metadata collection D = {d1, d2, ..., dn}
	Output: TF-IDF matrix M
	
	For each document d in D:
	Tokenize text into words
	Remove stopwords
	Convert words to lowercase
	
	For each term t in vocabulary:
	Compute document frequency df(t)
	
	For each document d:
	For each term t in d:
	tf = count(t in d) / total_terms(d)
	idf = log(N / df(t))
	M[d][t] = tf * idf
	
	Return M
\end{verbatim}

%------------------------------------------------------------
\subsection*{Cosine Similarity}

Cosine Similarity is used to measure the similarity between two vectors by computing the cosine of the angle between them. It is widely used in content-based recommender systems.

\subsubsection*{Formula}

\[
\text{CosineSimilarity}(A, B) = 
\frac{A \cdot B}{\|A\| \|B\|}
\]

Where:
\begin{itemize}
	\item $A \cdot B$ is the dot product of the vectors,
	\item $\|A\|$ and $\|B\|$ are the magnitudes of the vectors.
\end{itemize}

The similarity score ranges from 0 to 1 for TF-IDF vectors.

\subsubsection*{Pseudocode for Cosine Similarity}

\begin{verbatim}
	Algorithm Cosine_Similarity(A, B):
	Input: Two vectors A and B
	Output: Similarity score
	
	dot = Sum(A[i] * B[i] for each i)
	magA = sqrt(Sum(A[i]^2))
	magB = sqrt(Sum(B[i]^2))
	
	If magA == 0 or magB == 0:
	return 0
	
	similarity = dot / (magA * magB)
	return similarity
\end{verbatim}

%------------------------------------------------------------
\subsection*{Hybrid Recommendation Algorithm}

The Movie-RecommenderX system uses a hybrid recommendation approach that combines content-based filtering with collaborative filtering. This strategy leverages the strengths of both methods to produce more accurate and diverse recommendations.

\subsubsection*{1. Content-Based Filtering Steps}

\begin{enumerate}
	\item Preprocess textual metadata (genres, tags, overview).
	\item Generate TF-IDF feature vectors.
	\item Compute pairwise cosine similarity between all movie vectors.
	\item Retrieve the top-$N$ most similar movies for a given input movie.
\end{enumerate}

\subsubsection*{2. Collaborative Filtering Steps}

\begin{enumerate}
	\item Construct the user--movie rating matrix.
	\item Compute user similarity using cosine similarity or correlation.
	\item Predict ratings for unrated movies based on ratings of similar users.
\end{enumerate}

\subsubsection*{3. Hybrid Scoring Strategy}

The hybrid system combines the content-based and collaborative filtering scores using a weighted approach:

\[
Score = \alpha \times ContentScore + (1 - \alpha) \times CFScore
\]

where $0 \le \alpha \le 1$ is a weight factor (commonly $\alpha = 0.7$).

\subsubsection*{Pseudocode for Hybrid Recommendation}

\begin{verbatim}
	Algorithm Hybrid_Recommendation(user, movie):
	Input: user_id, movie_title
	Output: Top-N recommended movies
	
	Step 1: Content-based scores
	movie_vector = TFIDF[movie]
	For each movie m:
	content_score[m] = Cosine_Similarity(movie_vector, TFIDF[m])
	
	Step 2: Collaborative filtering scores
	For each user u:
	compute similarity between u and user
	For each movie m:
	cf_score[m] = weighted rating of similar users
	
	Step 3: Combine scores
	For each movie m:
	hybrid_score[m] = alpha * content_score[m] +
	(1 - alpha) * cf_score[m]
	
	Step 4: Sort movies by hybrid_score
	
	Step 5: Return Top-N movies
\end{verbatim}
\newpage

\section{\centering System Implementation}

\noindent
This chapter explains the implementation details of the movie recommendation system, covering the individual modules, data flow, and the internal processing performed at each stage. The system is built using Python and standard data science libraries such as \textbf{Pandas}, \textbf{NumPy}, \textbf{Scikit-learn}, and \textbf{Matplotlib}. 

The implementation is divided into four major modules:
\begin{itemize}
	\item Data Preprocessing
	\item Feature Engineering
	\item Similarity Engine
	\item Recommendation Module
\end{itemize}


\subsection{Module Description}

\subsubsection{Data Preprocessing Module}

The data preprocessing module is responsible for cleaning, validating, and transforming the raw movie dataset into a format suitable for machine learning algorithms. The input files used in this module include:

\begin{itemize}
	\item \texttt{movies.csv} -- contains movie titles and genres
	\item \texttt{ratings.csv} -- contains user ratings for movies
	\item \texttt{tags.csv} -- contains user-assigned tags
	\item Additional metadata files such as links and descriptions
\end{itemize}

\noindent
The preprocessing pipeline performs the following tasks:

\paragraph{1. Handling Missing Values}
Missing genres, tags, or descriptions are replaced with empty strings to prevent errors during TF--IDF vectorization and similarity computation.

\paragraph{2. Merging Multiple CSV Files}
The datasets are merged using \texttt{movieId} as the primary key to construct a unified movie metadata table. This ensures that every movie entry contains complete information (genres, tags, and optional descriptions).

\paragraph{3. Removing Duplicates}
Duplicate movie records and repeated tag entries are filtered out to maintain dataset consistency and avoid biased similarity scores.

\paragraph{4. Text Normalization}
To ensure uniform vectorization, the following text preprocessing steps are applied:
\begin{itemize}
	\item Conversion of all text to lowercase
	\item Removal of punctuation and special characters
	\item Removal of stopwords (common words with low information value)
	\item Optional token normalization or lemmatization
\end{itemize}

\paragraph{Final Structured Dataset}
After preprocessing, the module generates a clean and structured dataframe containing the required fields:

\begin{itemize}
	\item \texttt{movieId}
	\item \texttt{title}
	\item \texttt{genres}
	\item \texttt{tags}
	\item \texttt{combined\_features}
\end{itemize}

\noindent
This final dataset is then passed to the feature engineering module for TF--IDF vectorization and similarity computation.

\subsection{Data Preprocessing Module}

The Data Preprocessing Module is responsible for converting the raw movie metadata into a clean, consistent, and machine-readable format. Since the dataset is created by merging multiple CSV files such as \texttt{movies.csv}, \texttt{ratings.csv}, \texttt{tags.csv}, and additional metadata (IMDb ID, IMDb URL, and descriptions), this module ensures that all information is standardized before feature engineering. It forms the foundation for the TF--IDF vectorization and similarity computation stages.

\subsubsection*{Objectives}
\begin{itemize}
	\item Clean and validate noisy, inconsistent, or missing metadata.
	\item Merge multiple datasets into a unified movie information table.
	\item Normalize textual features for accurate vector representation.
	\item Prepare enriched metadata including IMDb-based information.
\end{itemize}

\subsubsection*{Internal Workflow}

\paragraph{1. Data Loading}
All raw CSV files are loaded using Pandas. Each file contributes essential metadata:
\begin{itemize}
	\item \texttt{movies.csv}: movieId, title, genres
	\item \texttt{tags.csv}: user-provided tags
	\item \texttt{ratings.csv}: user ratings for computing average rating
	\item Metadata file: \texttt{imdbId}, \texttt{imdb\_url}, and movie overview/description
\end{itemize}

\paragraph{2. Handling Missing Values}
Missing or incomplete fields such as genres, tags, or descriptions are replaced with safe placeholder text:
\begin{itemize}
	\item \textit{"unknown"} for missing genres
	\item empty string for missing tags
	\item \textit{"description not available"} for missing overviews
\end{itemize}
This prevents vectorization errors and ensures uniformity across movies.

\paragraph{3. Text Cleaning and Normalization}
All textual attributes undergo preprocessing to remove noise:
\begin{itemize}
	\item Conversion to lowercase
	\item Removal of punctuation, numeric symbols, and HTML traces
	\item Stopword removal to retain only meaningful terms
	\item Tokenization of text into individual words
\end{itemize}
These steps enhance the precision of TF--IDF vocabulary generation.

\paragraph{4. Dataset Merging}
All datasets are merged using \texttt{movieId} as the primary key. This merging produces a unified table containing:
\begin{itemize}
	\item Titles and genres  
	\item Aggregated tags from all users  
	\item Average rating calculated from \texttt{ratings.csv}  
	\item IMDb identifiers (\texttt{imdbId})  
	\item IMDb URLs (useful for linking movies to the external website)  
	\item Movie description / overview  
\end{itemize}

Duplicate rows are eliminated, and entries belonging to the same movie are grouped and combined (especially tags).

\paragraph{5. Construction of Final Structured Dataset}
After preprocessing and merging, the final structured dataset contains the following essential fields:
\begin{itemize}
	\item \texttt{movieId}
	\item \texttt{title}
	\item \texttt{genres}
	\item \texttt{tag} (merged user tags)
	\item \texttt{avg\_rating}
	\item \texttt{imdbId}
	\item \texttt{imdb\_url}
	\item \texttt{overview}
	\item \texttt{combined\_features} (genres + tags + overview)
\end{itemize}

The \texttt{combined\_features} column is the primary textual representation used for TF--IDF vectorization in the Feature Engineering Module.

\subsubsection*{Outcome}
The output of this module is a clean, normalized, and metadata-rich DataFrame. It ensures:
\begin{itemize}
	\item High-quality text representation for vectorization
	\item Consistent metadata for similarity computation
	\item A unified dataset with IMDb-enriched attributes
\end{itemize}
This dataset flows directly into the Feature Engineering Module for vector transformation.


\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.8\textwidth]{Dataset.png}
	\caption*{\textbf{Fig 5.1} Data preprocessing and Merging}
	\label{fig: 5.1}
\end{figure}

\subsection{Feature Engineering Module}

The Feature Engineering Module is responsible for converting textual metadata 
(\texttt{genres}, \texttt{tags}, \texttt{overview}, etc.) into numerical 
representations that can be processed by similarity algorithms. The primary 
technique used is Term Frequency--Inverse Document Frequency (TF--IDF), which 
captures the importance of a term within a document relative to the corpus.

\subsubsection*{1. Text Extraction and Corpus Construction}
After preprocessing, all relevant textual fields are merged into a single column 
called \texttt{combined\_features}. Example:
\begin{verbatim}
	combined_features = "action adventure heroic marvel universe superhero"
\end{verbatim}
A corpus is then constructed as a list of documents where each document 
corresponds to a single movie.

\begin{itemize}
	\item Each row represents one movie.
	\item Each document contains concatenated text from multiple metadata fields.
	\item Special characters, numbers, and stopwords have already been removed.
\end{itemize}

\subsubsection*{2. TF--IDF Vectorization}
TF--IDF converts the textual documents into a high-dimensional sparse numerical 
matrix. For each movie $i$ and term $t$:

\[
\text{TF-IDF}(t,i) = \text{TF}(t,i) \times \text{IDF}(t)
\]

where:
\[
\text{TF}(t,i) = \frac{\text{Number of occurrences of } t \text{ in movie } i}{\text{Total terms in movie } i}
\]
\[
\text{IDF}(t) = \log \left( \frac{N}{df(t)} \right)
\]

The resulting matrix:
\[
X \in \mathbb{R}^{M \times V}
\]
where:
\begin{itemize}
	\item $M$ = number of movies
	\item $V$ = vocabulary size
\end{itemize}

\subsubsection*{3. Vocabulary Construction}
During vectorization, the TF--IDF vectorizer extracts all unique words from the 
corpus:
\begin{itemize}
	\item Removes very rare words (via \texttt{min\_df})
	\item Removes extremely common words
	\item Builds a vocabulary dictionary mapping terms to indices
\end{itemize}

This vocabulary determines the columns of the TF--IDF matrix.

\subsubsection*{4. TF--IDF Normalization}
L2 normalization is applied to each movie vector:
\[
\hat{\mathbf{x}}_i = \frac{\mathbf{x}_i}{\|\mathbf{x}_i\|_2}
\]

This normalization ensures that cosine similarity becomes equivalent to the dot 
product:
\[
\cos(\theta) = \hat{\mathbf{x}}_i \cdot \hat{\mathbf{x}}_j
\]

\subsubsection*{5. Sparse Matrix Representation}
The TF--IDF matrix is extremely sparse. To store it efficiently:
\begin{itemize}
	\item Compressed Sparse Row (CSR) format is used.
	\item Only non-zero values are stored.
	\item Memory usage is reduced drastically.
\end{itemize}

\subsubsection*{6. Dimensionality Reduction (Optional)}
Although TF--IDF is powerful, it may produce a large vocabulary. Optional 
methods include:
\begin{itemize}
	\item Truncated SVD (Latent Semantic Analysis)
	\item Feature selection based on variance
\end{itemize}
This project retains TF--IDF without dimensionality reduction for clarity and 
interpretability.

\subsubsection*{Pseudocode for Feature Engineering}

\begin{verbatim}
	Algorithm Feature_Engineering(dataframe):
	Input: dataframe['combined_features']
	Output: TF-IDF sparse matrix X, vocabulary, metadata
	
	1. docs = dataframe['combined_features'].tolist()
	
	2. vectorizer = TfidfVectorizer(
	max_features = K,
	min_df = min_df,
	stop_words = custom_stopwords,
	ngram_range = (1,1),
	norm = 'l2'
	)
	
	3. X = vectorizer.fit_transform(docs)
	
	4. vocabulary = vectorizer.vocabulary_
	shape = X.shape
	
	Return X, vocabulary, shape
\end{verbatim}

\subsubsection*{Validation and Sanity Checks}
After vectorization, several validations are performed:
\begin{itemize}
	\item \textbf{Shape:} Verify $X$ has size $(M, V)$.
	\item \textbf{Sparsity:} Compute:
	\[
	\text{sparsity} = 1 - \frac{\text{nnz}(X)}{M \times V}
	\]
	\item \textbf{Top Terms:} Check highest TF--IDF terms for semantic quality.
	\item \textbf{Sample Vectors:} Inspect a few movie vectors for correctness.
\end{itemize}

\subsubsection*{Storage and Serialization}
To reuse the matrix without recomputation:
\begin{itemize}
	\item Save TF--IDF sparse matrix using \texttt{scipy.sparse.save\_npz}.
	\item Save vectorizer using \texttt{pickle}.
	\item Store metadata (vocabulary size, parameters) in JSON.
\end{itemize}

\subsubsection*{Integration with Similarity Engine}
The TF--IDF matrix becomes the direct input for the Similarity Engine. Since all 
vectors are L2-normalized, cosine similarity reduces to dot products, allowing 
fast retrieval using sparse operations.




\subsubsection*{Outcome}
The Feature Engineering Module produces:
\begin{itemize}
	\item Sparse TF--IDF matrix encoding movie metadata.
	\item Vocabulary index mapping.
	\item Diagnostic metrics (sparsity, matrix size).
\end{itemize}
These outputs feed directly into the Similarity Engine for content-based 
recommendations.


\subsection{Recommendation Module}

The Recommendation Module is the central component of the Movie-RecommenderX system. 
Its primary purpose is to generate relevant, accurate, and personalized movie suggestions for the user by utilizing the processed feature vectors and similarity scores computed in earlier stages. 
This module integrates the outputs from the Data Preprocessing, Feature Engineering, and Similarity Engine modules to generate meaningful recommendations based on the content and attributes of movies.

\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.8\textwidth]{TC3.png}
	\caption*{\textbf{Fig 5.2} First trail to check recommended movies}
	\label{fig:5.2}
\end{figure}

\subsubsection{Objective}

The primary objectives of the Recommendation Module are:

\begin{itemize}
	\item To generate movie suggestions that are closely related to the user's selected or preferred movie.
	\item To leverage content-based information using genres, keywords, tags, and metadata.
	\item To compute similarity-based rankings for efficient recommendation generation.
	\item To deliver personalized, relevant, and high-quality suggestions to enhance user experience.
\end{itemize}

\subsubsection{Inputs}

The Recommendation Module requires the following inputs:

\begin{itemize}
	\item \textbf{Movie Feature Vector:} A numerical representation of each movie created using techniques such as TF-IDF vectorization and combined textual embeddings.
	\item \textbf{Similarity Matrix:} A precomputed cosine similarity matrix that expresses the similarity between every pair of movies.
	\item \textbf{User Input:} A movie title selected by the user, which acts as the basis for generating recommendations.
\end{itemize}

\subsubsection{Working Mechanism}

The Recommendation Module follows a systematic workflow to generate suggestions:



\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.8\textwidth]{Workflow.png}
	\caption*{\textbf{Fig 5.3} Workflow of recommendation module}
	\label{fig: 5.3}
\end{figure}


\begin{enumerate}
	\item \textbf{Fetch Movie Index:}  
	The system locates the unique index of the movie specified by the user.
	
	\item \textbf{Retrieve Similarity Scores:}  
	Using the movie index, the module retrieves the corresponding row from the cosine similarity matrix.  
	This row contains similarity values between the chosen movie and all others.
	
	\item \textbf{Sort Movies by Similarity:}  
	The movies are sorted in decreasing order of similarity scores.  
	The selected movie is excluded from this list.
	
	\item \textbf{Select Top-N Movies:}  
	Based on the highest similarity values, the top $N$ movies (commonly 10 or 15) are selected.
	
	\item \textbf{Fetch Metadata:}  
	For each recommended movie, additional metadata such as title, genres, overview, and release year is extracted.
	
	\item \textbf{Generate Final Output:}  
	A structured and user-friendly list of recommended movies is prepared for display.
\end{enumerate}

\subsubsection{Similarity Calculation}

Cosine similarity is employed to compute similarity between movie feature vectors.  
For two vectors $A$ and $B$, cosine similarity is defined as:

\[
\text{similarity}(A, B) = \frac{A \cdot B}{\|A\| \|B\|}
\]

A higher similarity value indicates greater closeness between the movies.

\subsubsection{Algorithms and Techniques Used}

\begin{itemize}
	\item \textbf{TF-IDF Vectorization:} Converts textual descriptions, keywords, and tags into weighted numerical vectors.
	\item \textbf{Count Vectorization:} Represents word frequency and is used when simpler encoding is sufficient.
	\item \textbf{Cosine Similarity:} Measures closeness between movie vectors.
	\item \textbf{Hybrid Feature Combination:} Merges multiple textual features to enhance recommendation accuracy.
\end{itemize}

\subsubsection{Strengths}

\begin{itemize}
	\item Effective even for new users as it does not rely on user history (cold-start friendly for users).
	\item Highly interpretable and transparent since recommendations are based on content.
	\item Efficient due to precomputed similarity matrix.
	\item Scalable for large datasets and fast during runtime.
\end{itemize}

\subsubsection{Limitations}

\begin{itemize}
	\item Struggles with long-term preference modeling since it focuses only on content similarity.
	\item Depends on the completeness and quality of movie metadata.
	\item Features contribute equally unless specifically weighted.
\end{itemize}

\subsubsection{Example Recommendation Flow}

\textbf{User Input:} ``Inception''

\begin{enumerate}
	\item Retrieve feature vector corresponding to \textit{Inception}.
	\item Compute similarity of \textit{Inception} with all movies using cosine similarity.
	\item Sort movies based on similarity values.
	\item Select top 10 movies with the highest similarity scores.
	\item Present the final list to the user.
\end{enumerate}

\textbf{Example Output:}

\begin{itemize}
	\item Interstellar
	\item The Prestige
	\item Shutter Island
	\item Memento
	\item The Matrix
\end{itemize}


\newpage
\section{\centering System Testing}

\subsection{Unit Testing}

Unit testing is the process of testing individual components or modules of the Movie-RecommenderX system in isolation. Each module was tested independently to ensure that it behaves as expected before integrating it with other modules. The goal of unit testing is to detect errors at the earliest stage, particularly logical, functional, and data-related issues.

Unit tests were performed on the following major components:

\subsubsection*{1. Data Preprocessing Module}
This module was tested to verify:
\begin{itemize}
	\item Correct loading of CSV files (movies, tags, ratings).
	\item Handling of missing values without generating errors.
	\item Proper merging of datasets using \texttt{movieId}.
	\item Correct generation of the \texttt{combined\_features} column.
	\item Validation that no null values remain in text fields after cleaning.
\end{itemize}

\paragraph{Example Test Cases}
\begin{itemize}
	\item \textbf{TC1:} Check if all necessary CSV files load successfully.
	\item \textbf{TC2:} Ensure the merged dataframe has expected columns.
	\item \textbf{TC3:} Verify that no movie has missing tags or genres after preprocessing.
\end{itemize}



\begin{figure}[h!]
	\centering
	
	\begin{minipage}{0.45\textwidth}
		\centering
		\includegraphics[width=\linewidth]{Movies_csv.png}
		\caption*{Loading data of movies.csv}
	\end{minipage}
	\hfill
	\begin{minipage}{0.45\textwidth}
		\centering
		\includegraphics[width=\linewidth]{Ratings_csv.png}
		\caption*{Loading data of Ratings.csv}
	\end{minipage}
	
	\vspace{0.5cm}
	
	\begin{minipage}{0.45\textwidth}
		\centering
		\includegraphics[width=\linewidth]{Tags_csv.png}
		\caption*{Loading data of tags.csv}
	\end{minipage}
	\hfill
	\begin{minipage}{0.45\textwidth}
		\centering
		\includegraphics[width=\linewidth]{Merged_csv.png}
		\caption*{Loading data of Merged dataset.csv}
	\end{minipage}
	
	\caption*{\textbf{Fig 6.1}: Test case 1}
\end{figure}





\subsubsection*{2. Feature Engineering Module}
This module was tested to confirm that the TF--IDF vectorization works properly.
\begin{itemize}
	\item Test whether the TF--IDF matrix is successfully generated.
	\item Ensure the output matrix is sparse and non-empty.
	\item Verify that each movie corresponds to one TF--IDF vector.
	\item Check vocabulary size and correctness of tokenization.
\end{itemize}

\paragraph{Example Test Cases}
\begin{itemize}
	\item \textbf{TC4:} Validate that vectorizer produces the same vocabulary across sessions.
	\item \textbf{TC5:} Ensure \texttt{X.shape = (num\_movies, vocab\_size)}.
	\item \textbf{TC6:} Confirm sparsity percentage is within expected range.
\end{itemize}

\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.5\textwidth]{Similarity scores.png}
	\caption*{\textbf{Fig 6.2} Similarity scores in recommendation model}
	\label{fig: 6.2}
\end{figure}
\subsubsection*{3. Similarity Engine Module}
Unit tests ensured that similarity calculations were accurate and efficient.
\begin{itemize}
	\item Validate cosine similarity returns values in the range $[0,1]$.
	\item Test similarity output for identical movies (should be 1).
	\item Test similarity for completely unrelated movies (should be close to 0).
	\item Ensure performance when computing similarity for large matrices.
\end{itemize}




\paragraph{Example Test Cases}
\begin{itemize}
	\item \textbf{TC7:} Cosine similarity between identical vectors equals 1.
	\item \textbf{TC8:} Similarity between random vectors is low.
	\item \textbf{TC9:} Similarity computation completes within acceptable time.
\end{itemize}

\subsubsection*{4. Recommendation Module}
This module was tested to ensure that recommendations are correctly generated.
\begin{itemize}
	\item Input movie title returns Top-N similar movies.
	\item No duplicate movies appear in the recommendation list.
	\item Recommendations are sorted in decreasing similarity score.
	\item Module handles invalid movie titles gracefully.
\end{itemize}



\paragraph{Example Test Cases}
\begin{itemize}
	\item \textbf{TC10:} Check recommendation output size (N = 10).
	\item \textbf{TC11:} Validate descending order of similarity.
	\item \textbf{TC12:} Handle missing movie titles with an error message.
\end{itemize}


\subsubsection*{Unit Testing Outcome}
Unit testing confirmed that:
\begin{itemize}
	\item All modules operate correctly in isolation.
	\item No runtime errors occur during preprocessing or vectorization.
	\item Similarity scores are accurate and reproducible.
	\item The recommendation module generates correct, stable outputs.
\end{itemize}

\subsection{Integration Testing}

Integration Testing focuses on verifying that the individual modules, which have already been tested independently during Unit Testing, work together correctly when combined. While Unit Testing ensures that each function behaves as expected in isolation, Integration Testing ensures that these components interact seamlessly to support the complete workflow of the Movie-RecommenderX system.

For this project, Integration Testing plays a crucial role because the recommendation pipeline consists of multiple interconnected modules---dataset loading, preprocessing, feature extraction, similarity computation, and movie retrieval. Any failure in the interaction between these modules can lead to incorrect recommendations, runtime errors, or broken user interactions.

\subsection*{Objectives of Integration Testing}
The main goals of Integration Testing in this project include:
\begin{itemize}
	\item Ensuring that data flows correctly between different modules.
	\item Verifying that intermediate outputs from one component serve as valid inputs to the next.
	\item Detecting mismatches in data structures, formats, or expected values.
	\item Confirming that the complete recommendation pipeline executes without errors.
	\item Ensuring that the system behaves consistently in both Jupyter Notebook and the Streamlit-based interface.
\end{itemize}

\subsection*{Modules Considered for Integration}
The following components were integrated and tested in this study:
\begin{enumerate}
	\item \textbf{Dataset Loading Module}  
	Loads \texttt{movies.csv} and \texttt{tags.csv} using pandas.
	
	\item \textbf{Data Preprocessing Module}  
	Handles cleaning, merging datasets, generating tags, and constructing the final content features.
	
	\item \textbf{Feature Vectorization Module}  
	Uses TF-IDF or CountVectorizer to convert text data into numerical feature vectors.
	
	\item \textbf{Similarity Computation Module}  
	Computes cosine similarity among vectorized movie features.
	
	\item \textbf{Recommendation Engine}  
	Retrieves the top movies similar to the input movie or user query.
	
	\item \textbf{Frontend/API Module (Movie-recommenderX Interface)}  
	Streamlit interface that connects with the backend logic and displays recommended movies.
\end{enumerate}

\subsection*{Integration Testing Process}
Integration testing was performed using the incremental approach, where modules were combined and tested step-by-step.

\begin{enumerate}
	\item \textbf{Integrating Dataset Loading with Preprocessing}  
	The output DataFrame from the dataset loader was passed to the preprocessing script.  
	The test verified that the movie titles, genres, and tags merged correctly without missing values or datatype inconsistencies.
	
	\item \textbf{Integrating Preprocessing with Vectorization}  
	The cleaned and combined dataset was sent to the vectorizer.  
	Tests ensured that:
	\begin{itemize}
		\item all rows were vectorized,
		\item no text field was empty or malformed,
		\item vector dimensions matched expected sizes.
	\end{itemize}
	
	\item \textbf{Integrating Vectorization with Similarity Computation}  
	The similarity function was tested using the generated feature matrix.  
	The test validated that:
	\begin{itemize}
		\item cosine similarity produced a symmetric matrix,
		\item no NaN or infinite similarity values occurred,
		\item memory usage remained manageable.
	\end{itemize}
	
	\item \textbf{Integrating Backend Recommendation Engine}  
	The recommendation function received similarity scores and movie indices.  
	This test ensured that recommended movies matched the highest similarity scores and that index mapping was accurate.
	
	\item \textbf{Integrating Backend with Streamlit Frontend}  
	The final integration test verified that:
	\begin{itemize}
		\item the user-selected movie from the dropdown triggered the backend engine,
		\item the correct set of recommended movies was displayed,
		\item images, titles, and details loaded without errors.
	\end{itemize}
\end{enumerate}

\subsection*{Sample Integration Test Cases}
Below are two representative test cases used during integration:

\subsubsection*{Test Case 1: Integration of Preprocessing + Vectorization}
\begin{itemize}
	\item \textbf{Input:} Cleaned movie dataset after preprocessing.
	\item \textbf{Process:} Pass dataset to the TF-IDF/CountVectorizer module.
	\item \textbf{Expected Output:}  
	A valid numeric matrix where every movie has a corresponding feature vector of equal dimension.
	\item \textbf{Result:} Successfully passed; dimensionality and vector integrity verified.
\end{itemize}


\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.8\textwidth]{TC3.png}
	\caption*{Fig 6.3 Integration testing}
	\label{fig: 6.3}
\end{figure}



\subsubsection*{Test Case 2: Integration of Similarity Engine }
\begin{itemize}
	\item \textbf{Input:} A selected movie (e.g., \texttt{"Avatar"}).
	\item \textbf{Process:}  
	Streamlit UI triggers backend → similarity computation → recommendation function → UI display.
	\item \textbf{Expected Output:}  
	Top 5--10 similar movies displayed with posters and metadata.
	\item \textbf{Result:} Successfully integrated; verified correctness by cross-checking similarity rankings in Jupyter Notebook.
\end{itemize}


\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.8\textwidth]{ITC.png}
	\caption*{Fig 6.4 Finalized output for integration testing}
	\label{fig: 6.4}
\end{figure}

\subsection*{Outcome of Integration Testing}
Integration Testing confirmed that the entire Movie-RecommenderX pipeline functioned smoothly when all modules were combined. The system produced accurate recommendations, handled user inputs correctly, and maintained consistent performance across the notebook environment and the deployed interface. Any minor mismatches in data formatting were resolved during testing, ensuring a stable, end-to-end functional system.

\newpage
\section{\centering Results and Discussion}

This section presents the results obtained from the Movie-RecommenderX system and discusses the performance, accuracy, and overall behavior of the implemented hybrid recommendation approach. The evaluation includes results from both the prototype testing environment and the final integrated application.

\subsection{Overview of Results}

The system successfully processed and merged the three primary datasets: \texttt{movies.csv}, \texttt{ratings.csv}, and \texttt{tags.csv}. Using this combined dataset, the hybrid recommendation pipeline was executed by integrating content-based filtering (TF--IDF vectorization and cosine similarity) with collaborative filtering (user--item rating patterns).

The primary objective of this evaluation is to verify the correctness, relevance, and consistency of the movie recommendations produced by the system.

\subsection{Prototype Output Results}

During the initial testing phase in the Jupyter Notebook environment, all core modules such as dataset loading, preprocessing, feature extraction, and similarity computation were evaluated individually and then integrated.

The prototype generated accurate recommendations based on the given movie input. The recommended movies were found to closely match in terms of genre, plot description, and overall similarity score. These results confirm that the algorithmic logic of the hybrid model is implemented correctly.

\subsection{Final Application Output}

The system was further evaluated in the final Movie-RecommenderX application environment. The same input movies used during prototype testing were evaluated in the full application to ensure consistency.

The recommendations produced in the final application were consistent with those obtained in the Jupyter Notebook environment. This validates that all modules—data preprocessing, TF--IDF vectorization, cosine similarity calculation, and result rendering—were integrated correctly and function cohesively.

\subsection{Evaluation Metrics}

Standard evaluation metrics such as Mean Absolute Error (MAE), Root Mean Square Error (RMSE), Precision, and Recall were used to measure system performance.

The obtained results indicate that:

\begin{itemize}
	\item MAE and RMSE values demonstrate acceptable error margins for predicted ratings.
	\item A higher Precision value shows that most recommended movies are relevant to user preferences.
	\item A good Recall value indicates that the system successfully retrieves a majority of relevant items.
\end{itemize}

These metrics collectively confirm that the system performs efficiently and provides meaningful recommendations.






\begin{figure}[h!]
	\centering
	\begin{tabular}{cc}
		\includegraphics[width=0.45\textwidth]{Img1.png} &
		\includegraphics[width=0.45\textwidth]{Img2.png} \\[6pt]
		
		\includegraphics[width=0.45\textwidth]{Img3.png} &
		\includegraphics[width=0.45\textwidth]{Img4.png} \\[6pt]
	\end{tabular}
	\caption*{\textbf{Fig 7.1}: Output of Movie recommenderX}
	\label{fig:collage}
\end{figure}



\subsection{Discussion of Observations}

Key observations made during the evaluation include:

\begin{itemize}
	\item The hybrid recommendation approach delivers better accuracy and diversity compared to a purely content-based system.
	\item TF--IDF vectorization effectively captures textual similarities based on plot descriptions and genres.
	\item Cosine similarity ensures fast computation and efficient retrieval of similar movies.
	\item The system maintains stability and accuracy even when processing large datasets.
\end{itemize}

The recommendations generated by the system align well with human expectations, confirming its functional correctness.

\subsection{Strengths of the System}

\begin{itemize}
	\item Accurate and relevant recommendations using hybrid filtering.
	\item Efficient processing pipeline with fast similarity computation.
	\item Capable of handling large datasets without performance issues.
	\item Modular system design enables easy debugging and future enhancements.
\end{itemize}

\subsection{Limitations}

Despite its strengths, the system exhibits certain limitations:

\begin{itemize}
	\item Cold-start problem for new movies or users with insufficient data.
	\item Dependence on the quality and completeness of the movie overview text.
	\item Sparse rating data limits collaborative filtering accuracy.
	\item Recommendations are not dynamically updated unless datasets are reprocessed.
\end{itemize}

\subsection{Overall Summary}

In conclusion, the Movie-RecommenderX system successfully generates meaningful and relevant movie recommendations using a hybrid combination of content-based and collaborative filtering techniques. The results from both the prototype and final application demonstrate consistency and reliability. The system performs effectively and is suitable for real-world recommendation tasks, with potential for additional improvements in future work.

\vspace{1cm}
\begin{center}
	\textbf{Project Repository}\\[4pt]
	For source code, cloning, or contributions, visit:\\[6pt]
	\url{https://github.com/ravi1v/Movie-recommenderx}
\end{center}


\vspace{6cm}

\begin{center}
	\textbf{********************************}
\end{center}
\end{document}
